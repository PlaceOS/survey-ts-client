/* tslint:disable */
/* eslint-disable */
/**
 * staff-api
 * PlaceOS Staff-API description
 *
 * The version of the OpenAPI document: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * generic error feedback, backtraces only provided in development
 * @export
 * @interface ApplicationCommonError
 */
export interface ApplicationCommonError {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommonError
     */
    'error': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationCommonError
     */
    'backtrace'?: Array<string> | null;
}
/**
 * provides a list of acceptable content types if an unknown one is requested
 * @export
 * @interface ApplicationContentError
 */
export interface ApplicationContentError {
    /**
     * 
     * @type {string}
     * @memberof ApplicationContentError
     */
    'error': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationContentError
     */
    'accepts'?: Array<string> | null;
}
/**
 * Provides details on which parameter is missing or invalid
 * @export
 * @interface ApplicationParameterError
 */
export interface ApplicationParameterError {
    /**
     * 
     * @type {string}
     * @memberof ApplicationParameterError
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationParameterError
     */
    'parameter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationParameterError
     */
    'restriction'?: string | null;
}
/**
 * 
 * @export
 * @interface ApplicationValidationError
 */
export interface ApplicationValidationError {
    /**
     * 
     * @type {string}
     * @memberof ApplicationValidationError
     */
    'error': string;
    /**
     * 
     * @type {Array<ApplicationValidationErrorFailuresInner>}
     * @memberof ApplicationValidationError
     */
    'failures': Array<ApplicationValidationErrorFailuresInner>;
}
/**
 * 
 * @export
 * @interface ApplicationValidationErrorFailuresInner
 */
export interface ApplicationValidationErrorFailuresInner {
    /**
     * 
     * @type {string}
     * @memberof ApplicationValidationErrorFailuresInner
     */
    'field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationValidationErrorFailuresInner
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponse
 */
export interface AttendeeAttendeeResponseGuestGuestResponse {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'photo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'event'?: AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent | null;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'banned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'dangerous': boolean;
    /**
     * 
     * @type {object}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'extension_data': object;
    /**
     * 
     * @type {AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking}
     * @memberof AttendeeAttendeeResponseGuestGuestResponse
     */
    'booking'?: AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking | null;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOf
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOf {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'photo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf
     */
    'event'?: AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent | null;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOf1
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOf1 {
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'photo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'banned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'dangerous': boolean;
    /**
     * 
     * @type {object}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'extension_data': object;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'booking'?: AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking | null;
    /**
     * 
     * @type {AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1
     */
    'event'?: AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent | null;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking {
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'booking_type': string;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'booking_start': number;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'booking_end': number;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'asset_id': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'user_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'zones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'process_state'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'last_changed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'approved': boolean;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'approved_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'rejected': boolean;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'rejected_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'approver_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'approver_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'approver_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'department'?: string | null;
    /**
     * provided if this booking is associated with a calendar event
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'checked_in': boolean;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'checked_in_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'checked_out_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'deleted_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'booked_by_email': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'booked_by_name': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'booked_from'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'extension_data': object;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'current_state': AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingCurrentStateEnum;
    /**
     * 
     * @type {Array<AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory>}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'history': Array<AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory>;
    /**
     * 
     * @type {Array<AttendeeAttendeeResponseGuestGuestResponseAnyOf>}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1Booking
     */
    'attendees'?: Array<AttendeeAttendeeResponseGuestGuestResponseAnyOf> | null;
}

export const AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingCurrentStateEnum = {
    Reserved: 'reserved',
    CheckedIn: 'checked_in',
    CheckedOut: 'checked_out',
    NoShow: 'no_show',
    Rejected: 'rejected',
    Cancelled: 'cancelled',
    Ended: 'ended',
    Unknown: 'unknown'
} as const;

export type AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingCurrentStateEnum = typeof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingCurrentStateEnum[keyof typeof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingCurrentStateEnum];

/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory
     */
    'state': AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistoryStateEnum;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory
     */
    'time': number;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistory
     */
    'source'?: string | null;
}

export const AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistoryStateEnum = {
    Reserved: 'reserved',
    CheckedIn: 'checked_in',
    CheckedOut: 'checked_out',
    NoShow: 'no_show',
    Rejected: 'rejected',
    Cancelled: 'cancelled',
    Ended: 'ended',
    Unknown: 'unknown'
} as const;

export type AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistoryStateEnum = typeof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistoryStateEnum[keyof typeof AttendeeAttendeeResponseGuestGuestResponseAnyOf1BookingHistoryStateEnum];

/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'event_start': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'event_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'recurring_event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'host'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'body'?: string | null;
    /**
     * 
     * @type {Array<AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees>}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'attendees': Array<AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees>;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'location'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'all_day': boolean;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'recurring'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'updated'?: string | null;
    /**
     * 
     * @type {Array<AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments>}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'attachments': Array<AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments>;
    /**
     * 
     * @type {AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'recurrence'?: AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'creator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'ical_uid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'online_meeting_provider'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'online_meeting_phones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'online_meeting_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'online_meeting_sip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'online_meeting_pin'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'online_meeting_id'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'extended_properties'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'calendar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'system_id'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'system'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEvent
     */
    'recurring_master_id'?: string | null;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments
     */
    'content_bytes': string;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttachments
     */
    'size'?: number | null;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'response_status'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'resource'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'organizer'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {object}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'photo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'notes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'banned'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventAttendees
     */
    'dangerous'?: boolean | null;
}
/**
 * 
 * @export
 * @interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence
 */
export interface AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence {
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence
     */
    'range_start': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence
     */
    'range_end': string;
    /**
     * 
     * @type {number}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence
     */
    'interval': number;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence
     */
    'pattern': string;
    /**
     * 
     * @type {string}
     * @memberof AttendeeAttendeeResponseGuestGuestResponseAnyOfEventRecurrence
     */
    'days_of_week'?: string | null;
}
/**
 * 
 * @export
 * @interface BookingAssigner
 */
export interface BookingAssigner {
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInnerEventAttendeesInner>}
     * @memberof BookingAssigner
     */
    'attendees'?: Array<BookingBookingResponseAttendeesInnerEventAttendeesInner> | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'user_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'user_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'asset_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingAssigner
     */
    'zones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'email_digest'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'booking_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'booking_start'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'booking_end'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingAssigner
     */
    'deleted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'deleted_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingAssigner
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'checked_in_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'checked_out_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingAssigner
     */
    'rejected'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'rejected_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingAssigner
     */
    'approved'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'approved_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'approver_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'approver_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'approver_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'department'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'booked_by_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'booked_by_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'booked_by_email_digest'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'booked_by_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'booked_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingAssigner
     */
    'process_state'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'last_changed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'created'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof BookingAssigner
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {Array<BookingBookingResponseHistoryInner>}
     * @memberof BookingAssigner
     */
    'history'?: Array<BookingBookingResponseHistoryInner> | null;
    /**
     * 
     * @type {number}
     * @memberof BookingAssigner
     */
    'tenant_id'?: number | null;
}
/**
 * 
 * @export
 * @interface BookingBookingResponse
 */
export interface BookingBookingResponse {
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'booking_type': string;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'booking_start': number;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'booking_end': number;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'asset_id': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'user_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponse
     */
    'zones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'process_state'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'last_changed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponse
     */
    'approved': boolean;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'approved_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponse
     */
    'rejected': boolean;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'rejected_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'approver_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'approver_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'approver_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'department'?: string | null;
    /**
     * provided if this booking is associated with a calendar event
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponse
     */
    'checked_in': boolean;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'checked_in_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'checked_out_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponse
     */
    'deleted_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'booked_by_email': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'booked_by_name': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'booked_from'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof BookingBookingResponse
     */
    'extension_data': object;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponse
     */
    'current_state': BookingBookingResponseCurrentStateEnum;
    /**
     * 
     * @type {Array<BookingBookingResponseHistoryInner>}
     * @memberof BookingBookingResponse
     */
    'history': Array<BookingBookingResponseHistoryInner>;
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInner>}
     * @memberof BookingBookingResponse
     */
    'attendees'?: Array<BookingBookingResponseAttendeesInner> | null;
}

export const BookingBookingResponseCurrentStateEnum = {
    Reserved: 'reserved',
    CheckedIn: 'checked_in',
    CheckedOut: 'checked_out',
    NoShow: 'no_show',
    Rejected: 'rejected',
    Cancelled: 'cancelled',
    Ended: 'ended',
    Unknown: 'unknown'
} as const;

export type BookingBookingResponseCurrentStateEnum = typeof BookingBookingResponseCurrentStateEnum[keyof typeof BookingBookingResponseCurrentStateEnum];

/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInner
 */
export interface BookingBookingResponseAttendeesInner {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'photo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {BookingBookingResponseAttendeesInnerEvent}
     * @memberof BookingBookingResponseAttendeesInner
     */
    'event'?: BookingBookingResponseAttendeesInnerEvent | null;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEvent
 */
export interface BookingBookingResponseAttendeesInnerEvent {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'event_start': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'event_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'recurring_event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'host'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'body'?: string | null;
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInnerEventAttendeesInner>}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'attendees': Array<BookingBookingResponseAttendeesInnerEventAttendeesInner>;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'location'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'all_day': boolean;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'recurring'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'updated'?: string | null;
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInnerEventAttachmentsInner>}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'attachments': Array<BookingBookingResponseAttendeesInnerEventAttachmentsInner>;
    /**
     * 
     * @type {BookingBookingResponseAttendeesInnerEventRecurrence}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'recurrence'?: BookingBookingResponseAttendeesInnerEventRecurrence | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'creator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'ical_uid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'online_meeting_provider'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'online_meeting_phones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'online_meeting_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'online_meeting_sip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'online_meeting_pin'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'online_meeting_id'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'extended_properties'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'calendar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'system_id'?: string | null;
    /**
     * 
     * @type {BookingBookingResponseAttendeesInnerEventSystem}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'system'?: BookingBookingResponseAttendeesInnerEventSystem | null;
    /**
     * 
     * @type {object}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEvent
     */
    'recurring_master_id'?: string | null;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEventAttachmentsInner
 */
export interface BookingBookingResponseAttendeesInnerEventAttachmentsInner {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttachmentsInner
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttachmentsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttachmentsInner
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttachmentsInner
     */
    'content_bytes': string;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventAttachmentsInner
     */
    'size'?: number | null;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEventAttendeesInner
 */
export interface BookingBookingResponseAttendeesInnerEventAttendeesInner {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'response_status'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'resource'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'organizer'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {object}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'photo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'notes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'banned'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventAttendeesInner
     */
    'dangerous'?: boolean | null;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEventRecurrence
 */
export interface BookingBookingResponseAttendeesInnerEventRecurrence {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventRecurrence
     */
    'range_start': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventRecurrence
     */
    'range_end': string;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventRecurrence
     */
    'interval': number;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventRecurrence
     */
    'pattern': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventRecurrence
     */
    'days_of_week'?: string | null;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEventSystem
 */
export interface BookingBookingResponseAttendeesInnerEventSystem {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'zones': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'modules': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'map_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'capacity': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'features': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'bookable': boolean;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'installed_ui_devices': number;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'support_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventSystem
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEventSystemAnyOf
 */
export interface BookingBookingResponseAttendeesInnerEventSystemAnyOf {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseAttendeesInnerEventSystemAnyOf1
 */
export interface BookingBookingResponseAttendeesInnerEventSystemAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'zones': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'modules': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'map_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'capacity': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'features': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'bookable': boolean;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'installed_ui_devices': number;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'support_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseAttendeesInnerEventSystemAnyOf1
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface BookingBookingResponseHistoryInner
 */
export interface BookingBookingResponseHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseHistoryInner
     */
    'state': BookingBookingResponseHistoryInnerStateEnum;
    /**
     * 
     * @type {number}
     * @memberof BookingBookingResponseHistoryInner
     */
    'time': number;
    /**
     * 
     * @type {string}
     * @memberof BookingBookingResponseHistoryInner
     */
    'source'?: string | null;
}

export const BookingBookingResponseHistoryInnerStateEnum = {
    Reserved: 'reserved',
    CheckedIn: 'checked_in',
    CheckedOut: 'checked_out',
    NoShow: 'no_show',
    Rejected: 'rejected',
    Cancelled: 'cancelled',
    Ended: 'ended',
    Unknown: 'unknown'
} as const;

export type BookingBookingResponseHistoryInnerStateEnum = typeof BookingBookingResponseHistoryInnerStateEnum[keyof typeof BookingBookingResponseHistoryInnerStateEnum];

/**
 * returned when there is a booking clash or limit reached
 * @export
 * @interface BookingsBookingError
 */
export interface BookingsBookingError {
    /**
     * 
     * @type {string}
     * @memberof BookingsBookingError
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof BookingsBookingError
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof BookingsBookingError
     */
    'bookings'?: Array<object> | null;
}
/**
 * 
 * @export
 * @interface CalendarsAvailability
 */
export interface CalendarsAvailability {
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailability
     */
    'id': string;
    /**
     * 
     * @type {CalendarsAvailabilitySystem}
     * @memberof CalendarsAvailability
     */
    'system'?: CalendarsAvailabilitySystem | null;
    /**
     * 
     * @type {Array<CalendarsAvailabilityAvailabilityInner>}
     * @memberof CalendarsAvailability
     */
    'availability'?: Array<CalendarsAvailabilityAvailabilityInner> | null;
}
/**
 * 
 * @export
 * @interface CalendarsAvailabilityAvailabilityInner
 */
export interface CalendarsAvailabilityAvailabilityInner {
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilityAvailabilityInner
     */
    'status': CalendarsAvailabilityAvailabilityInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilityAvailabilityInner
     */
    'starts_at': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilityAvailabilityInner
     */
    'ends_at': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilityAvailabilityInner
     */
    'timezone': string;
}

export const CalendarsAvailabilityAvailabilityInnerStatusEnum = {
    Free: 'free',
    Busy: 'busy'
} as const;

export type CalendarsAvailabilityAvailabilityInnerStatusEnum = typeof CalendarsAvailabilityAvailabilityInnerStatusEnum[keyof typeof CalendarsAvailabilityAvailabilityInnerStatusEnum];

/**
 * 
 * @export
 * @interface CalendarsAvailabilitySystem
 */
export interface CalendarsAvailabilitySystem {
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CalendarsAvailabilitySystem
     */
    'zones': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CalendarsAvailabilitySystem
     */
    'modules': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'map_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CalendarsAvailabilitySystem
     */
    'capacity': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CalendarsAvailabilitySystem
     */
    'features': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CalendarsAvailabilitySystem
     */
    'bookable': boolean;
    /**
     * 
     * @type {number}
     * @memberof CalendarsAvailabilitySystem
     */
    'installed_ui_devices': number;
    /**
     * 
     * @type {string}
     * @memberof CalendarsAvailabilitySystem
     */
    'support_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CalendarsAvailabilitySystem
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface EventMetadataAssigner
 */
export interface EventMetadataAssigner {
    /**
     * 
     * @type {number}
     * @memberof EventMetadataAssigner
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EventMetadataAssigner
     */
    'system_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EventMetadataAssigner
     */
    'event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EventMetadataAssigner
     */
    'recurring_master_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EventMetadataAssigner
     */
    'ical_uid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EventMetadataAssigner
     */
    'host_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EventMetadataAssigner
     */
    'resource_calendar'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EventMetadataAssigner
     */
    'event_start'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EventMetadataAssigner
     */
    'event_end'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof EventMetadataAssigner
     */
    'ext_data'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof EventMetadataAssigner
     */
    'tenant_id'?: number | null;
}
/**
 * 
 * @export
 * @interface GuestAssigner
 */
export interface GuestAssigner {
    /**
     * 
     * @type {number}
     * @memberof GuestAssigner
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'photo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestAssigner
     */
    'banned'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestAssigner
     */
    'dangerous'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof GuestAssigner
     */
    'searchable'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof GuestAssigner
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof GuestAssigner
     */
    'tenant_id'?: number | null;
}
/**
 * 
 * @export
 * @interface GuestGuestResponse
 */
export interface GuestGuestResponse {
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'preferred_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'organisation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponse
     */
    'photo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponse
     */
    'banned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponse
     */
    'dangerous': boolean;
    /**
     * 
     * @type {object}
     * @memberof GuestGuestResponse
     */
    'extension_data': object;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponse
     */
    'checked_in'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponse
     */
    'visit_expected'?: boolean | null;
    /**
     * 
     * @type {GuestGuestResponseBooking}
     * @memberof GuestGuestResponse
     */
    'booking'?: GuestGuestResponseBooking | null;
    /**
     * 
     * @type {BookingBookingResponseAttendeesInnerEvent}
     * @memberof GuestGuestResponse
     */
    'event'?: BookingBookingResponseAttendeesInnerEvent | null;
}
/**
 * 
 * @export
 * @interface GuestGuestResponseBooking
 */
export interface GuestGuestResponseBooking {
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'booking_type': string;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'booking_start': number;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'booking_end': number;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'asset_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'user_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GuestGuestResponseBooking
     */
    'zones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'process_state'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'last_changed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponseBooking
     */
    'approved': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'approved_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponseBooking
     */
    'rejected': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'rejected_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'approver_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'approver_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'approver_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'department'?: string | null;
    /**
     * provided if this booking is associated with a calendar event
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponseBooking
     */
    'checked_in': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'checked_in_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'checked_out_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuestGuestResponseBooking
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuestGuestResponseBooking
     */
    'deleted_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'booked_by_email': string;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'booked_by_name': string;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'booked_from'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof GuestGuestResponseBooking
     */
    'extension_data': object;
    /**
     * 
     * @type {string}
     * @memberof GuestGuestResponseBooking
     */
    'current_state': GuestGuestResponseBookingCurrentStateEnum;
    /**
     * 
     * @type {Array<BookingBookingResponseHistoryInner>}
     * @memberof GuestGuestResponseBooking
     */
    'history': Array<BookingBookingResponseHistoryInner>;
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInner>}
     * @memberof GuestGuestResponseBooking
     */
    'attendees'?: Array<BookingBookingResponseAttendeesInner> | null;
}

export const GuestGuestResponseBookingCurrentStateEnum = {
    Reserved: 'reserved',
    CheckedIn: 'checked_in',
    CheckedOut: 'checked_out',
    NoShow: 'no_show',
    Rejected: 'rejected',
    Cancelled: 'cancelled',
    Ended: 'ended',
    Unknown: 'unknown'
} as const;

export type GuestGuestResponseBookingCurrentStateEnum = typeof GuestGuestResponseBookingCurrentStateEnum[keyof typeof GuestGuestResponseBookingCurrentStateEnum];

/**
 * 
 * @export
 * @interface GuestsShowIdParameter
 */
export interface GuestsShowIdParameter {
}
/**
 * 
 * @export
 * @interface HealthCheckBuildInfo
 */
export interface HealthCheckBuildInfo {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckBuildInfo
     */
    'commit': string;
    /**
     * 
     * @type {string}
     * @memberof HealthCheckBuildInfo
     */
    'build_time': string;
}
/**
 * 
 * @export
 * @interface PlaceCalendarCalendar
 */
export interface PlaceCalendarCalendar {
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarCalendar
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarCalendar
     */
    'ref'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarCalendar
     */
    'summary': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceCalendarCalendar
     */
    'primary': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceCalendarCalendar
     */
    'can_edit'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PlaceCalendarEvent
 */
export interface PlaceCalendarEvent {
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'event_start': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'event_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'recurring_event_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'host'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'body'?: string | null;
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInnerEventAttendeesInner>}
     * @memberof PlaceCalendarEvent
     */
    'attendees': Array<BookingBookingResponseAttendeesInnerEventAttendeesInner>;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'location'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceCalendarEvent
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceCalendarEvent
     */
    'all_day': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceCalendarEvent
     */
    'recurring'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'updated'?: string | null;
    /**
     * 
     * @type {Array<BookingBookingResponseAttendeesInnerEventAttachmentsInner>}
     * @memberof PlaceCalendarEvent
     */
    'attachments': Array<BookingBookingResponseAttendeesInnerEventAttachmentsInner>;
    /**
     * 
     * @type {BookingBookingResponseAttendeesInnerEventRecurrence}
     * @memberof PlaceCalendarEvent
     */
    'recurrence'?: BookingBookingResponseAttendeesInnerEventRecurrence | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'creator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'ical_uid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'online_meeting_provider'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlaceCalendarEvent
     */
    'online_meeting_phones'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'online_meeting_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'online_meeting_sip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'online_meeting_pin'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'online_meeting_id'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlaceCalendarEvent
     */
    'extended_properties'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'calendar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'system_id'?: string | null;
    /**
     * 
     * @type {BookingBookingResponseAttendeesInnerEventSystem}
     * @memberof PlaceCalendarEvent
     */
    'system'?: BookingBookingResponseAttendeesInnerEventSystem | null;
    /**
     * 
     * @type {object}
     * @memberof PlaceCalendarEvent
     */
    'extension_data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarEvent
     */
    'recurring_master_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PlaceCalendarGroup
 */
export interface PlaceCalendarGroup {
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarGroup
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarGroup
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PlaceCalendarMember
 */
export interface PlaceCalendarMember {
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarMember
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarMember
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarMember
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarMember
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PlaceCalendarUser
 */
export interface PlaceCalendarUser {
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'department'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'photo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceCalendarUser
     */
    'username'?: string | null;
}
/**
 * 
 * @export
 * @interface SurveyResponder
 */
export interface SurveyResponder {
    /**
     * 
     * @type {number}
     * @memberof SurveyResponder
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SurveyResponder
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SurveyResponder
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof SurveyResponder
     */
    'question_order'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface TenantResponder
 */
export interface TenantResponder {
    /**
     * 
     * @type {number}
     * @memberof TenantResponder
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponder
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponder
     */
    'domain'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponder
     */
    'platform'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TenantResponder
     */
    'delegated'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponder
     */
    'service_account'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof TenantResponder
     */
    'credentials'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof TenantResponder
     */
    'booking_limits'?: object | null;
    /**
     * 
     * @type {TenantResponderOutlookConfig}
     * @memberof TenantResponder
     */
    'outlook_config'?: TenantResponderOutlookConfig | null;
}
/**
 * 
 * @export
 * @interface TenantResponderOutlookConfig
 */
export interface TenantResponderOutlookConfig {
    /**
     * 
     * @type {string}
     * @memberof TenantResponderOutlookConfig
     */
    'app_id': string;
    /**
     * 
     * @type {string}
     * @memberof TenantResponderOutlookConfig
     */
    'base_path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponderOutlookConfig
     */
    'app_domain'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponderOutlookConfig
     */
    'app_resource'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TenantResponderOutlookConfig
     */
    'source_location'?: string | null;
}

/**
 * BookingsApi - axios parameter creator
 * @export
 */
export const BookingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approves a booking (if booking approval is required in an organisation)
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsApprove: async (id: number, utmSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsApprove', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary indicates that a booking has commenced
         * @param {number} id 
         * @param {boolean} [state] the desired value of the booking checked-in flag
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsCheckIn: async (id: number, state?: boolean, utmSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsCheckIn', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}/check_in`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary indicates that a booking has commenced
         * @param {number} id 
         * @param {boolean} [state] the desired value of the booking checked-in flag
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsCheckIn2: async (id: number, state?: boolean, utmSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsCheckIn2', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}/checkin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a new booking
         * @param {BookingAssigner} bookingAssigner 
         * @param {string} [utmSource] provided for use with analytics
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsCreate: async (bookingAssigner: BookingAssigner, utmSource?: string, limitOverride?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookingAssigner' is not null or undefined
            assertParamExists('bookingsCreate', 'bookingAssigner', bookingAssigner)
            const localVarPath = `/api/staff/v1/bookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }

            if (limitOverride !== undefined) {
                localVarQueryParameter['limit_override'] = limitOverride;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookingAssigner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary marks the provided booking as deleted
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsDestroy: async (id: number, utmSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsDestroy', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary marks the standalone visitor as checked-in or checked-out based on the state param
         * @param {number} id 
         * @param {string} guestId the email of the guest we want to checkin
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsGuestCheckin: async (id: number, guestId: string, state?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsGuestCheckin', 'id', id)
            // verify required parameter 'guestId' is not null or undefined
            assertParamExists('bookingsGuestCheckin', 'guestId', guestId)
            const localVarPath = `/api/staff/v1/bookings/{id}/guests/{guest_id}/check_in`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"guest_id"}}`, encodeURIComponent(String(guestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary marks the standalone visitor as checked-in or checked-out based on the state param
         * @param {number} id 
         * @param {string} guestId the email of the guest we want to checkin
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsGuestCheckin2: async (id: number, guestId: string, state?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsGuestCheckin2', 'id', id)
            // verify required parameter 'guestId' is not null or undefined
            assertParamExists('bookingsGuestCheckin2', 'guestId', guestId)
            const localVarPath = `/api/staff/v1/bookings/{id}/guests/{guest_id}/checkin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"guest_id"}}`, encodeURIComponent(String(guestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns a list of guests associated with a booking
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsGuestList: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsGuestList', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}/guests`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lists bookings based on the parameters provided
         * @param {number} periodStart booking period start as a unix epoch
         * @param {number} periodEnd booking period end as a unix epoch
         * @param {string} type the generic name of the asset whose bookings you wish to view
         * @param {boolean} [deleted] when true, it returns deleted bookings
         * @param {boolean} [includeCheckedOut] when true, returns all bookings including checked out ones
         * @param {boolean} [checkedOut] when true, only returns checked out bookings, unless &#x60;include_checked_out&#x3D;true&#x60;
         * @param {string} [zones] this filters only bookings in the zones provided, multiple zones can be provided comma seperated
         * @param {string} [email] filters bookings owned by this user email
         * @param {string} [user] filters bookings owned by this user id
         * @param {boolean} [includeBookedBy] if &#x60;email&#x60; or &#x60;user&#x60; parameters are set, this includes bookings that user booked on behalf of others
         * @param {boolean} [checkedIn] filters bookings that have been checked in or not
         * @param {number} [createdBefore] filters bookings that were created before the unix epoch specified
         * @param {number} [createdAfter] filters bookings that were created after the unix epoch specified
         * @param {boolean} [approved] filters bookings that are approved or not
         * @param {boolean} [rejected] filters bookings that are rejected or not
         * @param {string} [extensionData] filters bookings with matching extension data entries
         * @param {string} [state] filters on the booking process state, a user defined value
         * @param {string} [department] filters bookings owned by a department, a user defined value
         * @param {string} [eventId] filters bookings associated with an event, such as an Office365 Calendar event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsIndex: async (periodStart: number, periodEnd: number, type: string, deleted?: boolean, includeCheckedOut?: boolean, checkedOut?: boolean, zones?: string, email?: string, user?: string, includeBookedBy?: boolean, checkedIn?: boolean, createdBefore?: number, createdAfter?: number, approved?: boolean, rejected?: boolean, extensionData?: string, state?: string, department?: string, eventId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodStart' is not null or undefined
            assertParamExists('bookingsIndex', 'periodStart', periodStart)
            // verify required parameter 'periodEnd' is not null or undefined
            assertParamExists('bookingsIndex', 'periodEnd', periodEnd)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('bookingsIndex', 'type', type)
            const localVarPath = `/api/staff/v1/bookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (periodStart !== undefined) {
                localVarQueryParameter['period_start'] = periodStart;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (includeCheckedOut !== undefined) {
                localVarQueryParameter['include_checked_out'] = includeCheckedOut;
            }

            if (checkedOut !== undefined) {
                localVarQueryParameter['checked_out'] = checkedOut;
            }

            if (zones !== undefined) {
                localVarQueryParameter['zones'] = zones;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (includeBookedBy !== undefined) {
                localVarQueryParameter['include_booked_by'] = includeBookedBy;
            }

            if (checkedIn !== undefined) {
                localVarQueryParameter['checked_in'] = checkedIn;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = createdAfter;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (rejected !== undefined) {
                localVarQueryParameter['rejected'] = rejected;
            }

            if (extensionData !== undefined) {
                localVarQueryParameter['extension_data'] = extensionData;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (department !== undefined) {
                localVarQueryParameter['department'] = department;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['event_id'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rejects a booking
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsReject: async (id: number, utmSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsReject', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the booking requested
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsShow: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsShow', 'id', id)
            const localVarPath = `/api/staff/v1/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {BookingAssigner} bookingAssigner 
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsUpdate: async (id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsUpdate', 'id', id)
            // verify required parameter 'bookingAssigner' is not null or undefined
            assertParamExists('bookingsUpdate', 'bookingAssigner', bookingAssigner)
            const localVarPath = `/api/staff/v1/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limitOverride !== undefined) {
                localVarQueryParameter['limit_override'] = limitOverride;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookingAssigner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {BookingAssigner} bookingAssigner 
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsUpdate2: async (id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsUpdate2', 'id', id)
            // verify required parameter 'bookingAssigner' is not null or undefined
            assertParamExists('bookingsUpdate2', 'bookingAssigner', bookingAssigner)
            const localVarPath = `/api/staff/v1/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limitOverride !== undefined) {
                localVarQueryParameter['limit_override'] = limitOverride;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookingAssigner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary the current state of a booking, if a custom state machine is being used
         * @param {number} id 
         * @param {string} state the user defined process state of the booking
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsUpdateState: async (id: number, state: string, utmSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookingsUpdateState', 'id', id)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('bookingsUpdateState', 'state', state)
            const localVarPath = `/api/staff/v1/bookings/{id}/update_state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (utmSource !== undefined) {
                localVarQueryParameter['utm_source'] = utmSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookingsApi - functional programming interface
 * @export
 */
export const BookingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary approves a booking (if booking approval is required in an organisation)
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsApprove(id: number, utmSource?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsApprove(id, utmSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary indicates that a booking has commenced
         * @param {number} id 
         * @param {boolean} [state] the desired value of the booking checked-in flag
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsCheckIn(id: number, state?: boolean, utmSource?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsCheckIn(id, state, utmSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary indicates that a booking has commenced
         * @param {number} id 
         * @param {boolean} [state] the desired value of the booking checked-in flag
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsCheckIn2(id: number, state?: boolean, utmSource?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsCheckIn2(id, state, utmSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary creates a new booking
         * @param {BookingAssigner} bookingAssigner 
         * @param {string} [utmSource] provided for use with analytics
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsCreate(bookingAssigner: BookingAssigner, utmSource?: string, limitOverride?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsCreate(bookingAssigner, utmSource, limitOverride, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary marks the provided booking as deleted
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsDestroy(id: number, utmSource?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsDestroy(id, utmSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary marks the standalone visitor as checked-in or checked-out based on the state param
         * @param {number} id 
         * @param {string} guestId the email of the guest we want to checkin
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsGuestCheckin(id: number, guestId: string, state?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsGuestCheckin(id, guestId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary marks the standalone visitor as checked-in or checked-out based on the state param
         * @param {number} id 
         * @param {string} guestId the email of the guest we want to checkin
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsGuestCheckin2(id: number, guestId: string, state?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsGuestCheckin2(id, guestId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns a list of guests associated with a booking
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsGuestList(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestGuestResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsGuestList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lists bookings based on the parameters provided
         * @param {number} periodStart booking period start as a unix epoch
         * @param {number} periodEnd booking period end as a unix epoch
         * @param {string} type the generic name of the asset whose bookings you wish to view
         * @param {boolean} [deleted] when true, it returns deleted bookings
         * @param {boolean} [includeCheckedOut] when true, returns all bookings including checked out ones
         * @param {boolean} [checkedOut] when true, only returns checked out bookings, unless &#x60;include_checked_out&#x3D;true&#x60;
         * @param {string} [zones] this filters only bookings in the zones provided, multiple zones can be provided comma seperated
         * @param {string} [email] filters bookings owned by this user email
         * @param {string} [user] filters bookings owned by this user id
         * @param {boolean} [includeBookedBy] if &#x60;email&#x60; or &#x60;user&#x60; parameters are set, this includes bookings that user booked on behalf of others
         * @param {boolean} [checkedIn] filters bookings that have been checked in or not
         * @param {number} [createdBefore] filters bookings that were created before the unix epoch specified
         * @param {number} [createdAfter] filters bookings that were created after the unix epoch specified
         * @param {boolean} [approved] filters bookings that are approved or not
         * @param {boolean} [rejected] filters bookings that are rejected or not
         * @param {string} [extensionData] filters bookings with matching extension data entries
         * @param {string} [state] filters on the booking process state, a user defined value
         * @param {string} [department] filters bookings owned by a department, a user defined value
         * @param {string} [eventId] filters bookings associated with an event, such as an Office365 Calendar event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsIndex(periodStart: number, periodEnd: number, type: string, deleted?: boolean, includeCheckedOut?: boolean, checkedOut?: boolean, zones?: string, email?: string, user?: string, includeBookedBy?: boolean, checkedIn?: boolean, createdBefore?: number, createdAfter?: number, approved?: boolean, rejected?: boolean, extensionData?: string, state?: string, department?: string, eventId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BookingBookingResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsIndex(periodStart, periodEnd, type, deleted, includeCheckedOut, checkedOut, zones, email, user, includeBookedBy, checkedIn, createdBefore, createdAfter, approved, rejected, extensionData, state, department, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary rejects a booking
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsReject(id: number, utmSource?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsReject(id, utmSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the booking requested
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsShow(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {BookingAssigner} bookingAssigner 
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsUpdate(id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsUpdate(id, bookingAssigner, limitOverride, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {BookingAssigner} bookingAssigner 
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsUpdate2(id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsUpdate2(id, bookingAssigner, limitOverride, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary the current state of a booking, if a custom state machine is being used
         * @param {number} id 
         * @param {string} state the user defined process state of the booking
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingsUpdateState(id: number, state: string, utmSource?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingsUpdateState(id, state, utmSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookingsApi - factory interface
 * @export
 */
export const BookingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookingsApiFp(configuration)
    return {
        /**
         * 
         * @summary approves a booking (if booking approval is required in an organisation)
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsApprove(id: number, utmSource?: string, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsApprove(id, utmSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary indicates that a booking has commenced
         * @param {number} id 
         * @param {boolean} [state] the desired value of the booking checked-in flag
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsCheckIn(id: number, state?: boolean, utmSource?: string, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsCheckIn(id, state, utmSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary indicates that a booking has commenced
         * @param {number} id 
         * @param {boolean} [state] the desired value of the booking checked-in flag
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsCheckIn2(id: number, state?: boolean, utmSource?: string, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsCheckIn2(id, state, utmSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a new booking
         * @param {BookingAssigner} bookingAssigner 
         * @param {string} [utmSource] provided for use with analytics
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsCreate(bookingAssigner: BookingAssigner, utmSource?: string, limitOverride?: number, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsCreate(bookingAssigner, utmSource, limitOverride, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary marks the provided booking as deleted
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsDestroy(id: number, utmSource?: string, options?: any): AxiosPromise<void> {
            return localVarFp.bookingsDestroy(id, utmSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary marks the standalone visitor as checked-in or checked-out based on the state param
         * @param {number} id 
         * @param {string} guestId the email of the guest we want to checkin
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsGuestCheckin(id: number, guestId: string, state?: boolean, options?: any): AxiosPromise<GuestGuestResponse> {
            return localVarFp.bookingsGuestCheckin(id, guestId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary marks the standalone visitor as checked-in or checked-out based on the state param
         * @param {number} id 
         * @param {string} guestId the email of the guest we want to checkin
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsGuestCheckin2(id: number, guestId: string, state?: boolean, options?: any): AxiosPromise<GuestGuestResponse> {
            return localVarFp.bookingsGuestCheckin2(id, guestId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns a list of guests associated with a booking
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsGuestList(id: number, options?: any): AxiosPromise<Array<GuestGuestResponse>> {
            return localVarFp.bookingsGuestList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lists bookings based on the parameters provided
         * @param {number} periodStart booking period start as a unix epoch
         * @param {number} periodEnd booking period end as a unix epoch
         * @param {string} type the generic name of the asset whose bookings you wish to view
         * @param {boolean} [deleted] when true, it returns deleted bookings
         * @param {boolean} [includeCheckedOut] when true, returns all bookings including checked out ones
         * @param {boolean} [checkedOut] when true, only returns checked out bookings, unless &#x60;include_checked_out&#x3D;true&#x60;
         * @param {string} [zones] this filters only bookings in the zones provided, multiple zones can be provided comma seperated
         * @param {string} [email] filters bookings owned by this user email
         * @param {string} [user] filters bookings owned by this user id
         * @param {boolean} [includeBookedBy] if &#x60;email&#x60; or &#x60;user&#x60; parameters are set, this includes bookings that user booked on behalf of others
         * @param {boolean} [checkedIn] filters bookings that have been checked in or not
         * @param {number} [createdBefore] filters bookings that were created before the unix epoch specified
         * @param {number} [createdAfter] filters bookings that were created after the unix epoch specified
         * @param {boolean} [approved] filters bookings that are approved or not
         * @param {boolean} [rejected] filters bookings that are rejected or not
         * @param {string} [extensionData] filters bookings with matching extension data entries
         * @param {string} [state] filters on the booking process state, a user defined value
         * @param {string} [department] filters bookings owned by a department, a user defined value
         * @param {string} [eventId] filters bookings associated with an event, such as an Office365 Calendar event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsIndex(periodStart: number, periodEnd: number, type: string, deleted?: boolean, includeCheckedOut?: boolean, checkedOut?: boolean, zones?: string, email?: string, user?: string, includeBookedBy?: boolean, checkedIn?: boolean, createdBefore?: number, createdAfter?: number, approved?: boolean, rejected?: boolean, extensionData?: string, state?: string, department?: string, eventId?: string, options?: any): AxiosPromise<Array<BookingBookingResponse>> {
            return localVarFp.bookingsIndex(periodStart, periodEnd, type, deleted, includeCheckedOut, checkedOut, zones, email, user, includeBookedBy, checkedIn, createdBefore, createdAfter, approved, rejected, extensionData, state, department, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary rejects a booking
         * @param {number} id 
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsReject(id: number, utmSource?: string, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsReject(id, utmSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the booking requested
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsShow(id: number, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsShow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {BookingAssigner} bookingAssigner 
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsUpdate(id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsUpdate(id, bookingAssigner, limitOverride, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {BookingAssigner} bookingAssigner 
         * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsUpdate2(id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsUpdate2(id, bookingAssigner, limitOverride, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary the current state of a booking, if a custom state machine is being used
         * @param {number} id 
         * @param {string} state the user defined process state of the booking
         * @param {string} [utmSource] provided for use with analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingsUpdateState(id: number, state: string, utmSource?: string, options?: any): AxiosPromise<BookingBookingResponse> {
            return localVarFp.bookingsUpdateState(id, state, utmSource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookingsApi - object-oriented interface
 * @export
 * @class BookingsApi
 * @extends {BaseAPI}
 */
export class BookingsApi extends BaseAPI {
    /**
     * 
     * @summary approves a booking (if booking approval is required in an organisation)
     * @param {number} id 
     * @param {string} [utmSource] provided for use with analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsApprove(id: number, utmSource?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsApprove(id, utmSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary indicates that a booking has commenced
     * @param {number} id 
     * @param {boolean} [state] the desired value of the booking checked-in flag
     * @param {string} [utmSource] provided for use with analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsCheckIn(id: number, state?: boolean, utmSource?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsCheckIn(id, state, utmSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary indicates that a booking has commenced
     * @param {number} id 
     * @param {boolean} [state] the desired value of the booking checked-in flag
     * @param {string} [utmSource] provided for use with analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsCheckIn2(id: number, state?: boolean, utmSource?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsCheckIn2(id, state, utmSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a new booking
     * @param {BookingAssigner} bookingAssigner 
     * @param {string} [utmSource] provided for use with analytics
     * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsCreate(bookingAssigner: BookingAssigner, utmSource?: string, limitOverride?: number, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsCreate(bookingAssigner, utmSource, limitOverride, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary marks the provided booking as deleted
     * @param {number} id 
     * @param {string} [utmSource] provided for use with analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsDestroy(id: number, utmSource?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsDestroy(id, utmSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary marks the standalone visitor as checked-in or checked-out based on the state param
     * @param {number} id 
     * @param {string} guestId the email of the guest we want to checkin
     * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsGuestCheckin(id: number, guestId: string, state?: boolean, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsGuestCheckin(id, guestId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary marks the standalone visitor as checked-in or checked-out based on the state param
     * @param {number} id 
     * @param {string} guestId the email of the guest we want to checkin
     * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsGuestCheckin2(id: number, guestId: string, state?: boolean, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsGuestCheckin2(id, guestId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns a list of guests associated with a booking
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsGuestList(id: number, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsGuestList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lists bookings based on the parameters provided
     * @param {number} periodStart booking period start as a unix epoch
     * @param {number} periodEnd booking period end as a unix epoch
     * @param {string} type the generic name of the asset whose bookings you wish to view
     * @param {boolean} [deleted] when true, it returns deleted bookings
     * @param {boolean} [includeCheckedOut] when true, returns all bookings including checked out ones
     * @param {boolean} [checkedOut] when true, only returns checked out bookings, unless &#x60;include_checked_out&#x3D;true&#x60;
     * @param {string} [zones] this filters only bookings in the zones provided, multiple zones can be provided comma seperated
     * @param {string} [email] filters bookings owned by this user email
     * @param {string} [user] filters bookings owned by this user id
     * @param {boolean} [includeBookedBy] if &#x60;email&#x60; or &#x60;user&#x60; parameters are set, this includes bookings that user booked on behalf of others
     * @param {boolean} [checkedIn] filters bookings that have been checked in or not
     * @param {number} [createdBefore] filters bookings that were created before the unix epoch specified
     * @param {number} [createdAfter] filters bookings that were created after the unix epoch specified
     * @param {boolean} [approved] filters bookings that are approved or not
     * @param {boolean} [rejected] filters bookings that are rejected or not
     * @param {string} [extensionData] filters bookings with matching extension data entries
     * @param {string} [state] filters on the booking process state, a user defined value
     * @param {string} [department] filters bookings owned by a department, a user defined value
     * @param {string} [eventId] filters bookings associated with an event, such as an Office365 Calendar event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsIndex(periodStart: number, periodEnd: number, type: string, deleted?: boolean, includeCheckedOut?: boolean, checkedOut?: boolean, zones?: string, email?: string, user?: string, includeBookedBy?: boolean, checkedIn?: boolean, createdBefore?: number, createdAfter?: number, approved?: boolean, rejected?: boolean, extensionData?: string, state?: string, department?: string, eventId?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsIndex(periodStart, periodEnd, type, deleted, includeCheckedOut, checkedOut, zones, email, user, includeBookedBy, checkedIn, createdBefore, createdAfter, approved, rejected, extensionData, state, department, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary rejects a booking
     * @param {number} id 
     * @param {string} [utmSource] provided for use with analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsReject(id: number, utmSource?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsReject(id, utmSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the booking requested
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsShow(id: number, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsShow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing booking with the changes provided
     * @param {number} id 
     * @param {BookingAssigner} bookingAssigner 
     * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsUpdate(id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsUpdate(id, bookingAssigner, limitOverride, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing booking with the changes provided
     * @param {number} id 
     * @param {BookingAssigner} bookingAssigner 
     * @param {number} [limitOverride] allows a client to override any limits imposed on bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsUpdate2(id: number, bookingAssigner: BookingAssigner, limitOverride?: number, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsUpdate2(id, bookingAssigner, limitOverride, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary the current state of a booking, if a custom state machine is being used
     * @param {number} id 
     * @param {string} state the user defined process state of the booking
     * @param {string} [utmSource] provided for use with analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsApi
     */
    public bookingsUpdateState(id: number, state: string, utmSource?: string, options?: AxiosRequestConfig) {
        return BookingsApiFp(this.configuration).bookingsUpdateState(id, state, utmSource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CalendarsApi - axios parameter creator
 * @export
 */
export const CalendarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checks for availability of matched calendars, returns a list of calendars with availability
         * @param {number} periodStart search period start as a unix epoch
         * @param {number} periodEnd search period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {string} [features] a comma seperated list of room features
         * @param {number} [capacity] 
         * @param {boolean} [bookable] only search for bookable or non-bookable rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarsAvailability: async (periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodStart' is not null or undefined
            assertParamExists('calendarsAvailability', 'periodStart', periodStart)
            // verify required parameter 'periodEnd' is not null or undefined
            assertParamExists('calendarsAvailability', 'periodEnd', periodEnd)
            const localVarPath = `/api/staff/v1/calendars/availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (periodStart !== undefined) {
                localVarQueryParameter['period_start'] = periodStart;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (calendars !== undefined) {
                localVarQueryParameter['calendars'] = calendars;
            }

            if (zoneIds !== undefined) {
                localVarQueryParameter['zone_ids'] = zoneIds;
            }

            if (systemIds !== undefined) {
                localVarQueryParameter['system_ids'] = systemIds;
            }

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }

            if (capacity !== undefined) {
                localVarQueryParameter['capacity'] = capacity;
            }

            if (bookable !== undefined) {
                localVarQueryParameter['bookable'] = bookable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds the busy times in the period provided on the selected calendars. Returns the calendars that have meetings overlapping provided period
         * @summary Finds the busy times in the period provided on the selected calendars.
         * @param {number} periodStart search period start as a unix epoch
         * @param {number} periodEnd search period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {string} [features] a comma seperated list of room features
         * @param {number} [capacity] 
         * @param {boolean} [bookable] only search for bookable or non-bookable rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarsFreeBusy: async (periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodStart' is not null or undefined
            assertParamExists('calendarsFreeBusy', 'periodStart', periodStart)
            // verify required parameter 'periodEnd' is not null or undefined
            assertParamExists('calendarsFreeBusy', 'periodEnd', periodEnd)
            const localVarPath = `/api/staff/v1/calendars/free_busy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (periodStart !== undefined) {
                localVarQueryParameter['period_start'] = periodStart;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (calendars !== undefined) {
                localVarQueryParameter['calendars'] = calendars;
            }

            if (zoneIds !== undefined) {
                localVarQueryParameter['zone_ids'] = zoneIds;
            }

            if (systemIds !== undefined) {
                localVarQueryParameter['system_ids'] = systemIds;
            }

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }

            if (capacity !== undefined) {
                localVarQueryParameter['capacity'] = capacity;
            }

            if (bookable !== undefined) {
                localVarQueryParameter['bookable'] = bookable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lists the users default calendars
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarsIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/calendars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarsApi - functional programming interface
 * @export
 */
export const CalendarsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary checks for availability of matched calendars, returns a list of calendars with availability
         * @param {number} periodStart search period start as a unix epoch
         * @param {number} periodEnd search period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {string} [features] a comma seperated list of room features
         * @param {number} [capacity] 
         * @param {boolean} [bookable] only search for bookable or non-bookable rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calendarsAvailability(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CalendarsAvailability>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calendarsAvailability(periodStart, periodEnd, calendars, zoneIds, systemIds, features, capacity, bookable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds the busy times in the period provided on the selected calendars. Returns the calendars that have meetings overlapping provided period
         * @summary Finds the busy times in the period provided on the selected calendars.
         * @param {number} periodStart search period start as a unix epoch
         * @param {number} periodEnd search period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {string} [features] a comma seperated list of room features
         * @param {number} [capacity] 
         * @param {boolean} [bookable] only search for bookable or non-bookable rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calendarsFreeBusy(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CalendarsAvailability>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calendarsFreeBusy(periodStart, periodEnd, calendars, zoneIds, systemIds, features, capacity, bookable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lists the users default calendars
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calendarsIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarCalendar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calendarsIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CalendarsApi - factory interface
 * @export
 */
export const CalendarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarsApiFp(configuration)
    return {
        /**
         * 
         * @summary checks for availability of matched calendars, returns a list of calendars with availability
         * @param {number} periodStart search period start as a unix epoch
         * @param {number} periodEnd search period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {string} [features] a comma seperated list of room features
         * @param {number} [capacity] 
         * @param {boolean} [bookable] only search for bookable or non-bookable rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarsAvailability(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options?: any): AxiosPromise<Array<CalendarsAvailability>> {
            return localVarFp.calendarsAvailability(periodStart, periodEnd, calendars, zoneIds, systemIds, features, capacity, bookable, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds the busy times in the period provided on the selected calendars. Returns the calendars that have meetings overlapping provided period
         * @summary Finds the busy times in the period provided on the selected calendars.
         * @param {number} periodStart search period start as a unix epoch
         * @param {number} periodEnd search period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {string} [features] a comma seperated list of room features
         * @param {number} [capacity] 
         * @param {boolean} [bookable] only search for bookable or non-bookable rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarsFreeBusy(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options?: any): AxiosPromise<Array<CalendarsAvailability>> {
            return localVarFp.calendarsFreeBusy(periodStart, periodEnd, calendars, zoneIds, systemIds, features, capacity, bookable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lists the users default calendars
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarsIndex(options?: any): AxiosPromise<Array<PlaceCalendarCalendar>> {
            return localVarFp.calendarsIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarsApi - object-oriented interface
 * @export
 * @class CalendarsApi
 * @extends {BaseAPI}
 */
export class CalendarsApi extends BaseAPI {
    /**
     * 
     * @summary checks for availability of matched calendars, returns a list of calendars with availability
     * @param {number} periodStart search period start as a unix epoch
     * @param {number} periodEnd search period end as a unix epoch
     * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
     * @param {string} [zoneIds] a comma seperated list of zone ids
     * @param {string} [systemIds] a comma seperated list of event spaces
     * @param {string} [features] a comma seperated list of room features
     * @param {number} [capacity] 
     * @param {boolean} [bookable] only search for bookable or non-bookable rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarsApi
     */
    public calendarsAvailability(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options?: AxiosRequestConfig) {
        return CalendarsApiFp(this.configuration).calendarsAvailability(periodStart, periodEnd, calendars, zoneIds, systemIds, features, capacity, bookable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds the busy times in the period provided on the selected calendars. Returns the calendars that have meetings overlapping provided period
     * @summary Finds the busy times in the period provided on the selected calendars.
     * @param {number} periodStart search period start as a unix epoch
     * @param {number} periodEnd search period end as a unix epoch
     * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
     * @param {string} [zoneIds] a comma seperated list of zone ids
     * @param {string} [systemIds] a comma seperated list of event spaces
     * @param {string} [features] a comma seperated list of room features
     * @param {number} [capacity] 
     * @param {boolean} [bookable] only search for bookable or non-bookable rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarsApi
     */
    public calendarsFreeBusy(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, features?: string, capacity?: number, bookable?: boolean, options?: AxiosRequestConfig) {
        return CalendarsApiFp(this.configuration).calendarsFreeBusy(periodStart, periodEnd, calendars, zoneIds, systemIds, features, capacity, bookable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lists the users default calendars
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarsApi
     */
    public calendarsIndex(options?: AxiosRequestConfig) {
        return CalendarsApiFp(this.configuration).calendarsIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approves / accepts the meeting on behalf of the event space
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsApprove: async (id: string, systemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsApprove', 'id', id)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('eventsApprove', 'systemId', systemId)
            const localVarPath = `/api/staff/v1/events/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a new calendar event
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate: async (placeCalendarEvent: PlaceCalendarEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeCalendarEvent' is not null or undefined
            assertParamExists('eventsCreate', 'placeCalendarEvent', placeCalendarEvent)
            const localVarPath = `/api/staff/v1/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeCalendarEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * cancels the meeting without deleting it visually the event will remain on the calendar with a line through it
         * @summary cancels the meeting without deleting it
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDecline: async (id: string, systemId?: string, calendar?: string, notify?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsDecline', 'id', id)
            const localVarPath = `/api/staff/v1/events/{id}/decline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (calendar !== undefined) {
                localVarQueryParameter['calendar'] = calendar;
            }

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes the event from the calendar, it will not appear as cancelled, it will be gone
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDestroy: async (id: string, systemId?: string, calendar?: string, notify?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsDestroy', 'id', id)
            const localVarPath = `/api/staff/v1/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (calendar !== undefined) {
                localVarQueryParameter['calendar'] = calendar;
            }

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary example route: /extension_metadata?field_name=colour&value=blue
         * @param {string} fieldName the field we want to query
         * @param {string} value value we want to match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsExtensionMetadata: async (fieldName: string, value: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fieldName' is not null or undefined
            assertParamExists('eventsExtensionMetadata', 'fieldName', fieldName)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('eventsExtensionMetadata', 'value', value)
            const localVarPath = `/api/staff/v1/events/extension_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fieldName !== undefined) {
                localVarQueryParameter['field_name'] = fieldName;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * a guest has arrived for a meeting in person. This route can be used to notify hosts
         * @summary a guest has arrived for a meeting in person.
         * @param {string} id the event id
         * @param {string} guestId the email of the guest we want to checkin
         * @param {string} [systemId] the event space associated with this event
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGuestCheckin: async (id: string, guestId: string, systemId?: string, state?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsGuestCheckin', 'id', id)
            // verify required parameter 'guestId' is not null or undefined
            assertParamExists('eventsGuestCheckin', 'guestId', guestId)
            const localVarPath = `/api/staff/v1/events/{id}/guests/{guest_id}/check_in`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"guest_id"}}`, encodeURIComponent(String(guestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * a guest has arrived for a meeting in person. This route can be used to notify hosts
         * @summary a guest has arrived for a meeting in person.
         * @param {string} id the event id
         * @param {string} guestId the email of the guest we want to checkin
         * @param {string} [systemId] the event space associated with this event
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGuestCheckin2: async (id: string, guestId: string, systemId?: string, state?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsGuestCheckin2', 'id', id)
            // verify required parameter 'guestId' is not null or undefined
            assertParamExists('eventsGuestCheckin2', 'guestId', guestId)
            const localVarPath = `/api/staff/v1/events/{id}/guests/{guest_id}/checkin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"guest_id"}}`, encodeURIComponent(String(guestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Event Guest management
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGuestList: async (id: string, systemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsGuestList', 'id', id)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('eventsGuestList', 'systemId', systemId)
            const localVarPath = `/api/staff/v1/events/{id}/guests`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lists events occuring in the period provided, by default on the current users calendar
         * @param {number} periodStart event period start as a unix epoch
         * @param {number} periodEnd event period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {boolean} [includeCancelled] includes events that have been marked as cancelled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIndex: async (periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, includeCancelled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodStart' is not null or undefined
            assertParamExists('eventsIndex', 'periodStart', periodStart)
            // verify required parameter 'periodEnd' is not null or undefined
            assertParamExists('eventsIndex', 'periodEnd', periodEnd)
            const localVarPath = `/api/staff/v1/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (periodStart !== undefined) {
                localVarQueryParameter['period_start'] = periodStart;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (calendars !== undefined) {
                localVarQueryParameter['calendars'] = calendars;
            }

            if (zoneIds !== undefined) {
                localVarQueryParameter['zone_ids'] = zoneIds;
            }

            if (systemIds !== undefined) {
                localVarQueryParameter['system_ids'] = systemIds;
            }

            if (includeCancelled !== undefined) {
                localVarQueryParameter['include_cancelled'] = includeCancelled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patches the metadata on a booking without touching the calendar event, only updates the keys provided in the request
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPatchMetadata: async (id: string, systemId: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsPatchMetadata', 'id', id)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('eventsPatchMetadata', 'systemId', systemId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('eventsPatchMetadata', 'body', body)
            const localVarPath = `/api/staff/v1/events/{id}/metadata/{system_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rejects / declines the meeting on behalf of the event space
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsReject: async (id: string, systemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsReject', 'id', id)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('eventsReject', 'systemId', systemId)
            const localVarPath = `/api/staff/v1/events/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replaces the metadata on a booking without touching the calendar event
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsReplaceMetadata: async (id: string, systemId: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsReplaceMetadata', 'id', id)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('eventsReplaceMetadata', 'systemId', systemId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('eventsReplaceMetadata', 'body', body)
            const localVarPath = `/api/staff/v1/events/{id}/metadata/{system_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the event requested
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsShow: async (id: string, systemId?: string, calendar?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsShow', 'id', id)
            const localVarPath = `/api/staff/v1/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (calendar !== undefined) {
                localVarQueryParameter['calendar'] = calendar;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
         * @param {string} id the event id
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate: async (id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsUpdate', 'id', id)
            // verify required parameter 'placeCalendarEvent' is not null or undefined
            assertParamExists('eventsUpdate', 'placeCalendarEvent', placeCalendarEvent)
            const localVarPath = `/api/staff/v1/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (calendar !== undefined) {
                localVarQueryParameter['calendar'] = calendar;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeCalendarEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
         * @param {string} id the event id
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate2: async (id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsUpdate2', 'id', id)
            // verify required parameter 'placeCalendarEvent' is not null or undefined
            assertParamExists('eventsUpdate2', 'placeCalendarEvent', placeCalendarEvent)
            const localVarPath = `/api/staff/v1/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (calendar !== undefined) {
                localVarQueryParameter['calendar'] = calendar;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeCalendarEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary approves / accepts the meeting on behalf of the event space
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsApprove(id: string, systemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsApprove(id, systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary creates a new calendar event
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsCreate(placeCalendarEvent: PlaceCalendarEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsCreate(placeCalendarEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * cancels the meeting without deleting it visually the event will remain on the calendar with a line through it
         * @summary cancels the meeting without deleting it
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsDecline(id: string, systemId?: string, calendar?: string, notify?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsDecline(id, systemId, calendar, notify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletes the event from the calendar, it will not appear as cancelled, it will be gone
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsDestroy(id: string, systemId?: string, calendar?: string, notify?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsDestroy(id, systemId, calendar, notify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary example route: /extension_metadata?field_name=colour&value=blue
         * @param {string} fieldName the field we want to query
         * @param {string} value value we want to match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsExtensionMetadata(fieldName: string, value: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventMetadataAssigner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsExtensionMetadata(fieldName, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * a guest has arrived for a meeting in person. This route can be used to notify hosts
         * @summary a guest has arrived for a meeting in person.
         * @param {string} id the event id
         * @param {string} guestId the email of the guest we want to checkin
         * @param {string} [systemId] the event space associated with this event
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsGuestCheckin(id: string, guestId: string, systemId?: string, state?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsGuestCheckin(id, guestId, systemId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * a guest has arrived for a meeting in person. This route can be used to notify hosts
         * @summary a guest has arrived for a meeting in person.
         * @param {string} id the event id
         * @param {string} guestId the email of the guest we want to checkin
         * @param {string} [systemId] the event space associated with this event
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsGuestCheckin2(id: string, guestId: string, systemId?: string, state?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsGuestCheckin2(id, guestId, systemId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Event Guest management
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsGuestList(id: string, systemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendeeAttendeeResponseGuestGuestResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsGuestList(id, systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lists events occuring in the period provided, by default on the current users calendar
         * @param {number} periodStart event period start as a unix epoch
         * @param {number} periodEnd event period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {boolean} [includeCancelled] includes events that have been marked as cancelled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIndex(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, includeCancelled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIndex(periodStart, periodEnd, calendars, zoneIds, systemIds, includeCancelled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patches the metadata on a booking without touching the calendar event, only updates the keys provided in the request
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsPatchMetadata(id: string, systemId: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsPatchMetadata(id, systemId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary rejects / declines the meeting on behalf of the event space
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsReject(id: string, systemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsReject(id, systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replaces the metadata on a booking without touching the calendar event
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsReplaceMetadata(id: string, systemId: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsReplaceMetadata(id, systemId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the event requested
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsShow(id: string, systemId?: string, calendar?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsShow(id, systemId, calendar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
         * @param {string} id the event id
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsUpdate(id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsUpdate(id, placeCalendarEvent, systemId, calendar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
         * @param {string} id the event id
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsUpdate2(id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsUpdate2(id, placeCalendarEvent, systemId, calendar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary approves / accepts the meeting on behalf of the event space
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsApprove(id: string, systemId: string, options?: any): AxiosPromise<PlaceCalendarEvent> {
            return localVarFp.eventsApprove(id, systemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a new calendar event
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate(placeCalendarEvent: PlaceCalendarEvent, options?: any): AxiosPromise<PlaceCalendarEvent> {
            return localVarFp.eventsCreate(placeCalendarEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * cancels the meeting without deleting it visually the event will remain on the calendar with a line through it
         * @summary cancels the meeting without deleting it
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDecline(id: string, systemId?: string, calendar?: string, notify?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.eventsDecline(id, systemId, calendar, notify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes the event from the calendar, it will not appear as cancelled, it will be gone
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDestroy(id: string, systemId?: string, calendar?: string, notify?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.eventsDestroy(id, systemId, calendar, notify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary example route: /extension_metadata?field_name=colour&value=blue
         * @param {string} fieldName the field we want to query
         * @param {string} value value we want to match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsExtensionMetadata(fieldName: string, value: string, options?: any): AxiosPromise<Array<EventMetadataAssigner>> {
            return localVarFp.eventsExtensionMetadata(fieldName, value, options).then((request) => request(axios, basePath));
        },
        /**
         * a guest has arrived for a meeting in person. This route can be used to notify hosts
         * @summary a guest has arrived for a meeting in person.
         * @param {string} id the event id
         * @param {string} guestId the email of the guest we want to checkin
         * @param {string} [systemId] the event space associated with this event
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGuestCheckin(id: string, guestId: string, systemId?: string, state?: boolean, options?: any): AxiosPromise<GuestGuestResponse> {
            return localVarFp.eventsGuestCheckin(id, guestId, systemId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * a guest has arrived for a meeting in person. This route can be used to notify hosts
         * @summary a guest has arrived for a meeting in person.
         * @param {string} id the event id
         * @param {string} guestId the email of the guest we want to checkin
         * @param {string} [systemId] the event space associated with this event
         * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGuestCheckin2(id: string, guestId: string, systemId?: string, state?: boolean, options?: any): AxiosPromise<GuestGuestResponse> {
            return localVarFp.eventsGuestCheckin2(id, guestId, systemId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Event Guest management
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGuestList(id: string, systemId: string, options?: any): AxiosPromise<Array<AttendeeAttendeeResponseGuestGuestResponse>> {
            return localVarFp.eventsGuestList(id, systemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lists events occuring in the period provided, by default on the current users calendar
         * @param {number} periodStart event period start as a unix epoch
         * @param {number} periodEnd event period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {boolean} [includeCancelled] includes events that have been marked as cancelled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIndex(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, includeCancelled?: boolean, options?: any): AxiosPromise<Array<PlaceCalendarEvent>> {
            return localVarFp.eventsIndex(periodStart, periodEnd, calendars, zoneIds, systemIds, includeCancelled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patches the metadata on a booking without touching the calendar event, only updates the keys provided in the request
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPatchMetadata(id: string, systemId: string, body: object, options?: any): AxiosPromise<object> {
            return localVarFp.eventsPatchMetadata(id, systemId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary rejects / declines the meeting on behalf of the event space
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsReject(id: string, systemId: string, options?: any): AxiosPromise<PlaceCalendarEvent> {
            return localVarFp.eventsReject(id, systemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replaces the metadata on a booking without touching the calendar event
         * @param {string} id the event id
         * @param {string} systemId the event space associated with this event
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsReplaceMetadata(id: string, systemId: string, body: object, options?: any): AxiosPromise<object> {
            return localVarFp.eventsReplaceMetadata(id, systemId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the event requested
         * @param {string} id the event id
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsShow(id: string, systemId?: string, calendar?: string, options?: any): AxiosPromise<PlaceCalendarEvent> {
            return localVarFp.eventsShow(id, systemId, calendar, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
         * @param {string} id the event id
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate(id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options?: any): AxiosPromise<PlaceCalendarEvent> {
            return localVarFp.eventsUpdate(id, placeCalendarEvent, systemId, calendar, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
         * @param {string} id the event id
         * @param {PlaceCalendarEvent} placeCalendarEvent 
         * @param {string} [systemId] the event space associated with this event
         * @param {string} [calendar] the users calendar associated with this event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate2(id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options?: any): AxiosPromise<PlaceCalendarEvent> {
            return localVarFp.eventsUpdate2(id, placeCalendarEvent, systemId, calendar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary approves / accepts the meeting on behalf of the event space
     * @param {string} id the event id
     * @param {string} systemId the event space associated with this event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsApprove(id: string, systemId: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsApprove(id, systemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a new calendar event
     * @param {PlaceCalendarEvent} placeCalendarEvent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsCreate(placeCalendarEvent: PlaceCalendarEvent, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsCreate(placeCalendarEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * cancels the meeting without deleting it visually the event will remain on the calendar with a line through it
     * @summary cancels the meeting without deleting it
     * @param {string} id the event id
     * @param {string} [systemId] the event space associated with this event
     * @param {string} [calendar] the users calendar associated with this event
     * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsDecline(id: string, systemId?: string, calendar?: string, notify?: boolean, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsDecline(id, systemId, calendar, notify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes the event from the calendar, it will not appear as cancelled, it will be gone
     * @param {string} id the event id
     * @param {string} [systemId] the event space associated with this event
     * @param {string} [calendar] the users calendar associated with this event
     * @param {boolean} [notify] set to &#x60;false&#x60; to prevent attendees being notified of the change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsDestroy(id: string, systemId?: string, calendar?: string, notify?: boolean, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsDestroy(id, systemId, calendar, notify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary example route: /extension_metadata?field_name=colour&value=blue
     * @param {string} fieldName the field we want to query
     * @param {string} value value we want to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsExtensionMetadata(fieldName: string, value: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsExtensionMetadata(fieldName, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * a guest has arrived for a meeting in person. This route can be used to notify hosts
     * @summary a guest has arrived for a meeting in person.
     * @param {string} id the event id
     * @param {string} guestId the email of the guest we want to checkin
     * @param {string} [systemId] the event space associated with this event
     * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsGuestCheckin(id: string, guestId: string, systemId?: string, state?: boolean, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsGuestCheckin(id, guestId, systemId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * a guest has arrived for a meeting in person. This route can be used to notify hosts
     * @summary a guest has arrived for a meeting in person.
     * @param {string} id the event id
     * @param {string} guestId the email of the guest we want to checkin
     * @param {string} [systemId] the event space associated with this event
     * @param {boolean} [state] the checkin state, defaults to &#x60;true&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsGuestCheckin2(id: string, guestId: string, systemId?: string, state?: boolean, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsGuestCheckin2(id, guestId, systemId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Event Guest management
     * @param {string} id the event id
     * @param {string} systemId the event space associated with this event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsGuestList(id: string, systemId: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsGuestList(id, systemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lists events occuring in the period provided, by default on the current users calendar
     * @param {number} periodStart event period start as a unix epoch
     * @param {number} periodEnd event period end as a unix epoch
     * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
     * @param {string} [zoneIds] a comma seperated list of zone ids
     * @param {string} [systemIds] a comma seperated list of event spaces
     * @param {boolean} [includeCancelled] includes events that have been marked as cancelled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIndex(periodStart: number, periodEnd: number, calendars?: string, zoneIds?: string, systemIds?: string, includeCancelled?: boolean, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsIndex(periodStart, periodEnd, calendars, zoneIds, systemIds, includeCancelled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patches the metadata on a booking without touching the calendar event, only updates the keys provided in the request
     * @param {string} id the event id
     * @param {string} systemId the event space associated with this event
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsPatchMetadata(id: string, systemId: string, body: object, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsPatchMetadata(id, systemId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary rejects / declines the meeting on behalf of the event space
     * @param {string} id the event id
     * @param {string} systemId the event space associated with this event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsReject(id: string, systemId: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsReject(id, systemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replaces the metadata on a booking without touching the calendar event
     * @param {string} id the event id
     * @param {string} systemId the event space associated with this event
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsReplaceMetadata(id: string, systemId: string, body: object, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsReplaceMetadata(id, systemId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the event requested
     * @param {string} id the event id
     * @param {string} [systemId] the event space associated with this event
     * @param {string} [calendar] the users calendar associated with this event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsShow(id: string, systemId?: string, calendar?: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsShow(id, systemId, calendar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
     * @param {string} id the event id
     * @param {PlaceCalendarEvent} placeCalendarEvent 
     * @param {string} [systemId] the event space associated with this event
     * @param {string} [calendar] the users calendar associated with this event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsUpdate(id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsUpdate(id, placeCalendarEvent, systemId, calendar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing booking with the changes provided, a system should be specified if the user doesn\'t own the event
     * @param {string} id the event id
     * @param {PlaceCalendarEvent} placeCalendarEvent 
     * @param {string} [systemId] the event space associated with this event
     * @param {string} [calendar] the users calendar associated with this event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsUpdate2(id: string, placeCalendarEvent: PlaceCalendarEvent, systemId?: string, calendar?: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsUpdate2(id, placeCalendarEvent, systemId, calendar, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns a list of user groups in the orgainisations directory
         * @param {string} [q] optional search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsIndex: async (q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the list of staff memebers in a particular user group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsMembers: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsMembers', 'id', id)
            const localVarPath = `/api/staff/v1/groups/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the details of the provided group id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsShow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsShow', 'id', id)
            const localVarPath = `/api/staff/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns a list of user groups in the orgainisations directory
         * @param {string} [q] optional search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsIndex(q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsIndex(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the list of staff memebers in a particular user group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsMembers(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsMembers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the details of the provided group id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsShow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary returns a list of user groups in the orgainisations directory
         * @param {string} [q] optional search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsIndex(q?: string, options?: any): AxiosPromise<Array<PlaceCalendarGroup>> {
            return localVarFp.groupsIndex(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the list of staff memebers in a particular user group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsMembers(id: string, options?: any): AxiosPromise<Array<PlaceCalendarMember>> {
            return localVarFp.groupsMembers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the details of the provided group id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsShow(id: string, options?: any): AxiosPromise<PlaceCalendarGroup> {
            return localVarFp.groupsShow(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary returns a list of user groups in the orgainisations directory
     * @param {string} [q] optional search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsIndex(q?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsIndex(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the list of staff memebers in a particular user group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsMembers(id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsMembers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the details of the provided group id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsShow(id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsShow(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GuestsApi - axios parameter creator
 * @export
 */
export const GuestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the list of bookings a guest is expected to or has attended in person
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {boolean} [includePast] shoule we include past bookings
         * @param {number} [limit] how many results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsBookings: async (id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('guestsBookings', 'id', id)
            const localVarPath = `/api/staff/v1/guests/{id}/bookings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includePast !== undefined) {
                localVarQueryParameter['include_past'] = includePast;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a new guest record
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsCreate: async (guestAssigner: GuestAssigner, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestAssigner' is not null or undefined
            assertParamExists('guestsCreate', 'guestAssigner', guestAssigner)
            const localVarPath = `/api/staff/v1/guests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guestAssigner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes the guest record from the database
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsDestroy: async (id: GuestsShowIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('guestsDestroy', 'id', id)
            const localVarPath = `/api/staff/v1/guests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lists known guests (which can be queried) OR locates visitors via meeting start and end times (can be filtered by calendars, zone_ids and system_ids)
         * @param {string} [q] space seperated search query for guests
         * @param {number} [periodStart] event period start as a unix epoch
         * @param {number} [periodEnd] event period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsIndex: async (q?: string, periodStart?: number, periodEnd?: number, calendars?: string, zoneIds?: string, systemIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/guests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (periodStart !== undefined) {
                localVarQueryParameter['period_start'] = periodStart;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (calendars !== undefined) {
                localVarQueryParameter['calendars'] = calendars;
            }

            if (zoneIds !== undefined) {
                localVarQueryParameter['zone_ids'] = zoneIds;
            }

            if (systemIds !== undefined) {
                localVarQueryParameter['system_ids'] = systemIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the meetings that the provided guest is attending today (approximation based on internal records)
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {boolean} [includePast] shoule we include past events they have visited
         * @param {number} [limit] how many results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsMeetings: async (id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('guestsMeetings', 'id', id)
            const localVarPath = `/api/staff/v1/guests/{id}/meetings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includePast !== undefined) {
                localVarQueryParameter['include_past'] = includePast;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the details of a particular guest and if they are expected to attend in person today
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsShow: async (id: GuestsShowIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('guestsShow', 'id', id)
            const localVarPath = `/api/staff/v1/guests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches a guest record with the changes provided
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsUpdate: async (id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('guestsUpdate', 'id', id)
            // verify required parameter 'guestAssigner' is not null or undefined
            assertParamExists('guestsUpdate', 'guestAssigner', guestAssigner)
            const localVarPath = `/api/staff/v1/guests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guestAssigner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches a guest record with the changes provided
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsUpdate2: async (id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('guestsUpdate2', 'id', id)
            // verify required parameter 'guestAssigner' is not null or undefined
            assertParamExists('guestsUpdate2', 'guestAssigner', guestAssigner)
            const localVarPath = `/api/staff/v1/guests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guestAssigner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestsApi - functional programming interface
 * @export
 */
export const GuestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the list of bookings a guest is expected to or has attended in person
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {boolean} [includePast] shoule we include past bookings
         * @param {number} [limit] how many results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsBookings(id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BookingBookingResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsBookings(id, includePast, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary creates a new guest record
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsCreate(guestAssigner: GuestAssigner, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsCreate(guestAssigner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary removes the guest record from the database
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsDestroy(id: GuestsShowIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lists known guests (which can be queried) OR locates visitors via meeting start and end times (can be filtered by calendars, zone_ids and system_ids)
         * @param {string} [q] space seperated search query for guests
         * @param {number} [periodStart] event period start as a unix epoch
         * @param {number} [periodEnd] event period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsIndex(q?: string, periodStart?: number, periodEnd?: number, calendars?: string, zoneIds?: string, systemIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendeeAttendeeResponseGuestGuestResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsIndex(q, periodStart, periodEnd, calendars, zoneIds, systemIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the meetings that the provided guest is attending today (approximation based on internal records)
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {boolean} [includePast] shoule we include past events they have visited
         * @param {number} [limit] how many results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsMeetings(id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsMeetings(id, includePast, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the details of a particular guest and if they are expected to attend in person today
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsShow(id: GuestsShowIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches a guest record with the changes provided
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsUpdate(id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsUpdate(id, guestAssigner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches a guest record with the changes provided
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestsUpdate2(id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestsUpdate2(id, guestAssigner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GuestsApi - factory interface
 * @export
 */
export const GuestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestsApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the list of bookings a guest is expected to or has attended in person
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {boolean} [includePast] shoule we include past bookings
         * @param {number} [limit] how many results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsBookings(id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options?: any): AxiosPromise<Array<BookingBookingResponse>> {
            return localVarFp.guestsBookings(id, includePast, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a new guest record
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsCreate(guestAssigner: GuestAssigner, options?: any): AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse> {
            return localVarFp.guestsCreate(guestAssigner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary removes the guest record from the database
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsDestroy(id: GuestsShowIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.guestsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lists known guests (which can be queried) OR locates visitors via meeting start and end times (can be filtered by calendars, zone_ids and system_ids)
         * @param {string} [q] space seperated search query for guests
         * @param {number} [periodStart] event period start as a unix epoch
         * @param {number} [periodEnd] event period end as a unix epoch
         * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
         * @param {string} [zoneIds] a comma seperated list of zone ids
         * @param {string} [systemIds] a comma seperated list of event spaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsIndex(q?: string, periodStart?: number, periodEnd?: number, calendars?: string, zoneIds?: string, systemIds?: string, options?: any): AxiosPromise<Array<AttendeeAttendeeResponseGuestGuestResponse>> {
            return localVarFp.guestsIndex(q, periodStart, periodEnd, calendars, zoneIds, systemIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the meetings that the provided guest is attending today (approximation based on internal records)
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {boolean} [includePast] shoule we include past events they have visited
         * @param {number} [limit] how many results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsMeetings(id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options?: any): AxiosPromise<Array<PlaceCalendarEvent>> {
            return localVarFp.guestsMeetings(id, includePast, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the details of a particular guest and if they are expected to attend in person today
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsShow(id: GuestsShowIdParameter, options?: any): AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse> {
            return localVarFp.guestsShow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches a guest record with the changes provided
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsUpdate(id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options?: any): AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse> {
            return localVarFp.guestsUpdate(id, guestAssigner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches a guest record with the changes provided
         * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
         * @param {GuestAssigner} guestAssigner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestsUpdate2(id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options?: any): AxiosPromise<AttendeeAttendeeResponseGuestGuestResponse> {
            return localVarFp.guestsUpdate2(id, guestAssigner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestsApi - object-oriented interface
 * @export
 * @class GuestsApi
 * @extends {BaseAPI}
 */
export class GuestsApi extends BaseAPI {
    /**
     * 
     * @summary returns the list of bookings a guest is expected to or has attended in person
     * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
     * @param {boolean} [includePast] shoule we include past bookings
     * @param {number} [limit] how many results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsBookings(id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsBookings(id, includePast, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a new guest record
     * @param {GuestAssigner} guestAssigner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsCreate(guestAssigner: GuestAssigner, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsCreate(guestAssigner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary removes the guest record from the database
     * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsDestroy(id: GuestsShowIdParameter, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lists known guests (which can be queried) OR locates visitors via meeting start and end times (can be filtered by calendars, zone_ids and system_ids)
     * @param {string} [q] space seperated search query for guests
     * @param {number} [periodStart] event period start as a unix epoch
     * @param {number} [periodEnd] event period end as a unix epoch
     * @param {string} [calendars] a comma seperated list of calendar ids, recommend using &#x60;system_id&#x60; for resource calendars
     * @param {string} [zoneIds] a comma seperated list of zone ids
     * @param {string} [systemIds] a comma seperated list of event spaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsIndex(q?: string, periodStart?: number, periodEnd?: number, calendars?: string, zoneIds?: string, systemIds?: string, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsIndex(q, periodStart, periodEnd, calendars, zoneIds, systemIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the meetings that the provided guest is attending today (approximation based on internal records)
     * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
     * @param {boolean} [includePast] shoule we include past events they have visited
     * @param {number} [limit] how many results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsMeetings(id: GuestsShowIdParameter, includePast?: boolean, limit?: number, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsMeetings(id, includePast, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the details of a particular guest and if they are expected to attend in person today
     * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsShow(id: GuestsShowIdParameter, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsShow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches a guest record with the changes provided
     * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
     * @param {GuestAssigner} guestAssigner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsUpdate(id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsUpdate(id, guestAssigner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches a guest record with the changes provided
     * @param {GuestsShowIdParameter} id looks up a guest using either their id or email
     * @param {GuestAssigner} guestAssigner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsApi
     */
    public guestsUpdate2(id: GuestsShowIdParameter, guestAssigner: GuestAssigner, options?: AxiosRequestConfig) {
        return GuestsApiFp(this.configuration).guestsUpdate2(id, guestAssigner, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the service build details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the service build details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckBuildInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the service build details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckIndex(options?: any): AxiosPromise<HealthCheckBuildInfo> {
            return localVarFp.healthCheckIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
    /**
     * 
     * @summary returns the service build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public healthCheckIndex(options?: AxiosRequestConfig) {
        return HealthCheckApiFp(this.configuration).healthCheckIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StaffApi - axios parameter creator
 * @export
 */
export const StaffApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the list of public calendars
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffCalendars: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('staffCalendars', 'id', id)
            const localVarPath = `/api/staff/v1/people/{id}/calendars`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the list of groups the user is a member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffGroups: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('staffGroups', 'id', id)
            const localVarPath = `/api/staff/v1/people/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lists users in the organisation directory
         * @param {string} [q] optional search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffIndex: async (q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the users manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffManager: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('staffManager', 'id', id)
            const localVarPath = `/api/staff/v1/people/{id}/manager`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns user details for the id provided
         * @param {string} id a user id OR user email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffShow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('staffShow', 'id', id)
            const localVarPath = `/api/staff/v1/people/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaffApi - functional programming interface
 * @export
 */
export const StaffApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaffApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the list of public calendars
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffCalendars(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarCalendar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffCalendars(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the list of groups the user is a member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffGroups(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffGroups(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lists users in the organisation directory
         * @param {string} [q] optional search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffIndex(q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceCalendarUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffIndex(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the users manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffManager(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffManager(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns user details for the id provided
         * @param {string} id a user id OR user email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffShow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceCalendarUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StaffApi - factory interface
 * @export
 */
export const StaffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaffApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the list of public calendars
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffCalendars(id: string, options?: any): AxiosPromise<Array<PlaceCalendarCalendar>> {
            return localVarFp.staffCalendars(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the list of groups the user is a member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffGroups(id: string, options?: any): AxiosPromise<Array<PlaceCalendarGroup>> {
            return localVarFp.staffGroups(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lists users in the organisation directory
         * @param {string} [q] optional search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffIndex(q?: string, options?: any): AxiosPromise<Array<PlaceCalendarUser>> {
            return localVarFp.staffIndex(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the users manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffManager(id: string, options?: any): AxiosPromise<PlaceCalendarUser> {
            return localVarFp.staffManager(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns user details for the id provided
         * @param {string} id a user id OR user email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffShow(id: string, options?: any): AxiosPromise<PlaceCalendarUser> {
            return localVarFp.staffShow(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaffApi - object-oriented interface
 * @export
 * @class StaffApi
 * @extends {BaseAPI}
 */
export class StaffApi extends BaseAPI {
    /**
     * 
     * @summary returns the list of public calendars
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public staffCalendars(id: string, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffCalendars(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the list of groups the user is a member
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public staffGroups(id: string, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffGroups(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lists users in the organisation directory
     * @param {string} [q] optional search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public staffIndex(q?: string, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffIndex(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the users manager
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public staffManager(id: string, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffManager(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns user details for the id provided
     * @param {string} id a user id OR user email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public staffShow(id: string, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffShow(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SurveysApi - axios parameter creator
 * @export
 */
export const SurveysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary creates a new survey
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysCreate: async (surveyResponder: SurveyResponder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'surveyResponder' is not null or undefined
            assertParamExists('surveysCreate', 'surveyResponder', surveyResponder)
            const localVarPath = `/api/staff/v1/surveys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(surveyResponder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes the survey
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('surveysDestroy', 'id', id)
            const localVarPath = `/api/staff/v1/surveys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns a list of surveys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/surveys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary show a survey
         * @param {string} id the survey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysShow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('surveysShow', 'id', id)
            const localVarPath = `/api/staff/v1/surveys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing survey
         * @param {number} id 
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysUpdate: async (id: number, surveyResponder: SurveyResponder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('surveysUpdate', 'id', id)
            // verify required parameter 'surveyResponder' is not null or undefined
            assertParamExists('surveysUpdate', 'surveyResponder', surveyResponder)
            const localVarPath = `/api/staff/v1/surveys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(surveyResponder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing survey
         * @param {number} id 
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysUpdate2: async (id: number, surveyResponder: SurveyResponder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('surveysUpdate2', 'id', id)
            // verify required parameter 'surveyResponder' is not null or undefined
            assertParamExists('surveysUpdate2', 'surveyResponder', surveyResponder)
            const localVarPath = `/api/staff/v1/surveys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(surveyResponder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SurveysApi - functional programming interface
 * @export
 */
export const SurveysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SurveysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary creates a new survey
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async surveysCreate(surveyResponder: SurveyResponder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SurveyResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.surveysCreate(surveyResponder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletes the survey
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async surveysDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.surveysDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns a list of surveys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async surveysIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SurveyResponder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.surveysIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary show a survey
         * @param {string} id the survey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async surveysShow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SurveyResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.surveysShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing survey
         * @param {number} id 
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async surveysUpdate(id: number, surveyResponder: SurveyResponder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SurveyResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.surveysUpdate(id, surveyResponder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing survey
         * @param {number} id 
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async surveysUpdate2(id: number, surveyResponder: SurveyResponder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SurveyResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.surveysUpdate2(id, surveyResponder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SurveysApi - factory interface
 * @export
 */
export const SurveysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SurveysApiFp(configuration)
    return {
        /**
         * 
         * @summary creates a new survey
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysCreate(surveyResponder: SurveyResponder, options?: any): AxiosPromise<SurveyResponder> {
            return localVarFp.surveysCreate(surveyResponder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes the survey
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.surveysDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns a list of surveys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysIndex(options?: any): AxiosPromise<Array<SurveyResponder>> {
            return localVarFp.surveysIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary show a survey
         * @param {string} id the survey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysShow(id: string, options?: any): AxiosPromise<SurveyResponder> {
            return localVarFp.surveysShow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing survey
         * @param {number} id 
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysUpdate(id: number, surveyResponder: SurveyResponder, options?: any): AxiosPromise<SurveyResponder> {
            return localVarFp.surveysUpdate(id, surveyResponder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing survey
         * @param {number} id 
         * @param {SurveyResponder} surveyResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveysUpdate2(id: number, surveyResponder: SurveyResponder, options?: any): AxiosPromise<SurveyResponder> {
            return localVarFp.surveysUpdate2(id, surveyResponder, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SurveysApi - object-oriented interface
 * @export
 * @class SurveysApi
 * @extends {BaseAPI}
 */
export class SurveysApi extends BaseAPI {
    /**
     * 
     * @summary creates a new survey
     * @param {SurveyResponder} surveyResponder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SurveysApi
     */
    public surveysCreate(surveyResponder: SurveyResponder, options?: AxiosRequestConfig) {
        return SurveysApiFp(this.configuration).surveysCreate(surveyResponder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes the survey
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SurveysApi
     */
    public surveysDestroy(id: number, options?: AxiosRequestConfig) {
        return SurveysApiFp(this.configuration).surveysDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns a list of surveys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SurveysApi
     */
    public surveysIndex(options?: AxiosRequestConfig) {
        return SurveysApiFp(this.configuration).surveysIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary show a survey
     * @param {string} id the survey id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SurveysApi
     */
    public surveysShow(id: string, options?: AxiosRequestConfig) {
        return SurveysApiFp(this.configuration).surveysShow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing survey
     * @param {number} id 
     * @param {SurveyResponder} surveyResponder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SurveysApi
     */
    public surveysUpdate(id: number, surveyResponder: SurveyResponder, options?: AxiosRequestConfig) {
        return SurveysApiFp(this.configuration).surveysUpdate(id, surveyResponder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing survey
     * @param {number} id 
     * @param {SurveyResponder} surveyResponder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SurveysApi
     */
    public surveysUpdate2(id: number, surveyResponder: SurveyResponder, options?: AxiosRequestConfig) {
        return SurveysApiFp(this.configuration).surveysUpdate2(id, surveyResponder, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantsApi - axios parameter creator
 * @export
 */
export const TenantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary creates a new tenant
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsCreate: async (tenantResponder: TenantResponder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantResponder' is not null or undefined
            assertParamExists('tenantsCreate', 'tenantResponder', tenantResponder)
            const localVarPath = `/api/staff/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantResponder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the limits for the current domain (Host header)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsCurrentLimits: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/tenants/current_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes the selected tenant from the system
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenantsDestroy', 'id', id)
            const localVarPath = `/api/staff/v1/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lists the configured tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/staff/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the limits for the selected tenant
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsShowLimits: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenantsShowLimits', 'id', id)
            const localVarPath = `/api/staff/v1/tenants/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsUpdate: async (id: number, tenantResponder: TenantResponder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenantsUpdate', 'id', id)
            // verify required parameter 'tenantResponder' is not null or undefined
            assertParamExists('tenantsUpdate', 'tenantResponder', tenantResponder)
            const localVarPath = `/api/staff/v1/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantResponder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsUpdate2: async (id: number, tenantResponder: TenantResponder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenantsUpdate2', 'id', id)
            // verify required parameter 'tenantResponder' is not null or undefined
            assertParamExists('tenantsUpdate2', 'tenantResponder', tenantResponder)
            const localVarPath = `/api/staff/v1/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantResponder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updates the limits for the tenant provided
         * @param {number} id 
         * @param {{ [key: string]: number; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsUpdateLimits: async (id: number, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenantsUpdateLimits', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('tenantsUpdateLimits', 'requestBody', requestBody)
            const localVarPath = `/api/staff/v1/tenants/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary creates a new tenant
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsCreate(tenantResponder: TenantResponder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsCreate(tenantResponder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the limits for the current domain (Host header)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsCurrentLimits(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsCurrentLimits(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary removes the selected tenant from the system
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lists the configured tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TenantResponder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the limits for the selected tenant
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsShowLimits(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsShowLimits(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsUpdate(id: number, tenantResponder: TenantResponder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsUpdate(id, tenantResponder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsUpdate2(id: number, tenantResponder: TenantResponder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantResponder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsUpdate2(id, tenantResponder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updates the limits for the tenant provided
         * @param {number} id 
         * @param {{ [key: string]: number; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsUpdateLimits(id: number, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsUpdateLimits(id, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantsApiFp(configuration)
    return {
        /**
         * 
         * @summary creates a new tenant
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsCreate(tenantResponder: TenantResponder, options?: any): AxiosPromise<TenantResponder> {
            return localVarFp.tenantsCreate(tenantResponder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the limits for the current domain (Host header)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsCurrentLimits(options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.tenantsCurrentLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary removes the selected tenant from the system
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tenantsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lists the configured tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsIndex(options?: any): AxiosPromise<Array<TenantResponder>> {
            return localVarFp.tenantsIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the limits for the selected tenant
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsShowLimits(id: number, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.tenantsShowLimits(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsUpdate(id: number, tenantResponder: TenantResponder, options?: any): AxiosPromise<TenantResponder> {
            return localVarFp.tenantsUpdate(id, tenantResponder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary patches an existing booking with the changes provided
         * @param {number} id 
         * @param {TenantResponder} tenantResponder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsUpdate2(id: number, tenantResponder: TenantResponder, options?: any): AxiosPromise<TenantResponder> {
            return localVarFp.tenantsUpdate2(id, tenantResponder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updates the limits for the tenant provided
         * @param {number} id 
         * @param {{ [key: string]: number; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsUpdateLimits(id: number, requestBody: { [key: string]: number; }, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.tenantsUpdateLimits(id, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * 
     * @summary creates a new tenant
     * @param {TenantResponder} tenantResponder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsCreate(tenantResponder: TenantResponder, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsCreate(tenantResponder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the limits for the current domain (Host header)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsCurrentLimits(options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsCurrentLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary removes the selected tenant from the system
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsDestroy(id: number, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lists the configured tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsIndex(options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the limits for the selected tenant
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsShowLimits(id: number, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsShowLimits(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing booking with the changes provided
     * @param {number} id 
     * @param {TenantResponder} tenantResponder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsUpdate(id: number, tenantResponder: TenantResponder, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsUpdate(id, tenantResponder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary patches an existing booking with the changes provided
     * @param {number} id 
     * @param {TenantResponder} tenantResponder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsUpdate2(id: number, tenantResponder: TenantResponder, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsUpdate2(id, tenantResponder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updates the limits for the tenant provided
     * @param {number} id 
     * @param {{ [key: string]: number; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsUpdateLimits(id: number, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsUpdateLimits(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


